<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="python脚本语言的理解（外部类和内部类为何对python不太重要）"><meta name="keywords" content="python"><meta name="author" content="Yunfei Zhang"><meta name="copyright" content="Yunfei Zhang"><title>python脚本语言的理解（外部类和内部类为何对python不太重要） | grassbloomy</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本情况"><span class="toc-number">1.</span> <span class="toc-text">基本情况</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#往常做法"><span class="toc-number">2.</span> <span class="toc-text">往常做法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#更新全局变量"><span class="toc-number">2.1.</span> <span class="toc-text">更新全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调用类外全局变量"><span class="toc-number">2.1.1.</span> <span class="toc-text">调用类外全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的静态变量"><span class="toc-number">2.1.2.</span> <span class="toc-text">类的静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回调函数"><span class="toc-number">2.1.3.</span> <span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类"><span class="toc-number">2.1.4.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更高级别架构：-MVP"><span class="toc-number">2.1.5.</span> <span class="toc-text">更高级别架构： MVP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#遇到问题"><span class="toc-number">3.</span> <span class="toc-text">遇到问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python的继承与Init"><span class="toc-number">3.1.</span> <span class="toc-text">Python的继承与Init</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对该机制的原因的进一步探究"><span class="toc-number">3.1.1.</span> <span class="toc-text">对该机制的原因的进一步探究</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解决办法"><span class="toc-number">4.</span> <span class="toc-text">解决办法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#不得已而为之的方法"><span class="toc-number">4.1.</span> <span class="toc-text">不得已而为之的方法</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Yunfei Zhang</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">6</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">4</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2019/07/06/5d2043345129b66140.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">grassbloomy</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">python脚本语言的理解（外部类和内部类为何对python不太重要）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/技术/">技术</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>这博客一放就是将近半年，想这半年来本来想写篇东西记录一下调试php和js的那些坑，但是后来才发现这些东西都是些碎片化的小知识点，当不得正式记录，其实在日志和文档中摸索，在debug的各种信息查找中，我确实收货了不少经验，而这些经验未必又是纪录得下来的，所以，能开这一篇，我应该感到庆幸，当然也许会被10年后的我嫌弃：“这么垃圾的知识点还要单开一篇文章，是不是傻？”唠嗑就说这么多，下面进入正题。<br><a id="more"></a><br>今天调试python的时候遇到一个问题，主要是关于多线程下类的相互调用，首先介绍一下基本情况。</p>
<h1 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h1><p>需要在一个已有的类上添加 Watchdog 例程，而该 watchdog 依赖于一个名为 FileEventHandler 的类，在该类中处理中断之后，调用已有的类的方法执行相对应的操作（函数）。在之前，我认为这种情况的解决方法有以下几种：更新全局变量（静态类变量或者是全局变量），传递回调函数。</p>
<h1 id="往常做法"><a href="#往常做法" class="headerlink" title="往常做法"></a>往常做法</h1><h2 id="更新全局变量"><a href="#更新全局变量" class="headerlink" title="更新全局变量"></a>更新全局变量</h2><h3 id="调用类外全局变量"><a href="#调用类外全局变量" class="headerlink" title="调用类外全局变量"></a>调用类外全局变量</h3><p>在程序运行域中添加全局变量，这是最容易想到，也是最为人不齿的方法，因为这种方法使得一个类调用了它之外的变量，在迁移的时候非常不方便，在 C 等面向过程语言中经常使用。\<br>同理，也可以在全局环境下定义函数，操作已存在的类，而这也是我们一般调用 API 所处在的环境，类对我们都是封装的，直接调用函数即可。</p>
<h3 id="类的静态变量"><a href="#类的静态变量" class="headerlink" title="类的静态变量"></a>类的静态变量</h3><p>但是我们想要让代码具有高可维护性，那就必须采用面向对象编程。这时我们可以采用类的静态变量（不同语言实现方法不同，但一般都有），这样就可以做到类的封闭性，但是这种情况只适用于一些超参数的配置，当需要使 new 的类的每一个都具有不同的，变量名称相同的变量，这种方法就不适用了。\<br>同理，我们也可以将一些没有动态编译内容的函数以语言所规定的形式将其标注为静态函数，这样就不用创建具体实例而可以直接调用静态方法。这在时间上减少了具体实例的初始化。</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>很多时候，回调函数是一个很好的选择，因为它可以带上类的上下文，直接在一个正在运行的类中修改它的内部信息和调用函数，直接将类的引用传递过去，就可以在新 class 中调用之前创建的类对象的函数了。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>当一个类只在另一个类生存周期内调用，那么可以将其设为内部类，这样就可以互相调用了。</p>
<h3 id="更高级别架构：-MVP"><a href="#更高级别架构：-MVP" class="headerlink" title="更高级别架构： MVP"></a>更高级别架构： MVP</h3><p>当我们需要互相调用的类实例很多时，就不能单单将其放在主程序中了，而若要对其进行科学的管理，就有必要将其封装成一个类，以类.函数的形式调用，所有类的回调函数都可以放在 presenter 层中，而对应的需要调用的函数就放在 model 层中。</p>
<h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p>上式中列出的解决方法似乎可以解决所有调用问题，然而在 Python 的特定环境下，还是会有问题出现。</p>
<h2 id="Python的继承与Init"><a href="#Python的继承与Init" class="headerlink" title="Python的继承与Init"></a>Python的继承与Init</h2><p>一般情况下，想要实现在 FileEventHandler 的函数中调用，只需要在初始化时传入对应函数类的引用即可，但是 FileEventHandler 是继承于 FileSystemEventHandler ，且需要在 FileEventHandler 的函数中调用 FileSystemEventHandler 的 init 函数，而 Python 的规则是，若要调用父类的 init 函数，则必须保持子类的 init 函数与父类的函数参数一致，这样就无法在初始化的时候将调用类的引用传入，而 init 函数就是类从外界获取参数的唯一地点，这个时候，就遇到问题了。</p>
<h3 id="对该机制的原因的进一步探究"><a href="#对该机制的原因的进一步探究" class="headerlink" title="对该机制的原因的进一步探究"></a>对该机制的原因的进一步探究</h3><p>这里有时间可以编辑一些</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>还是被之前的静态语言束缚住了手脚，在脚本语言中，完全可以先执行一部分代码后再定义类，这样就能直接在 FileEventHandler 的函数中以主程序的名空间调用之前初始化的实例了。</p>
<h2 id="不得已而为之的方法"><a href="#不得已而为之的方法" class="headerlink" title="不得已而为之的方法"></a>不得已而为之的方法</h2><p>实际上可以对 lib 文件下手，修改 init 函数，也能解决这一问题，但这样一来就破坏了结构性。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2019/09/17/hadoop和hbase安装遇到的坑/"><span>hadoop和hbase安装遇到的坑</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2019/07/06/5d2043345129b66140.png)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By Yunfei Zhang</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>